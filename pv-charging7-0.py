from set_amps import set_amp
from count_stops import counter
from status import status_and_sleep
from get_data import retrieve_values
from set_chargings import set_charging
from logger import log_error, log_info
from check_1_phase import check_1_phase
from charging_profiles import adaptive_charging, slow_charging, no_charging
from power_calcultions import calculate_available_power, check_max_charging_power

def evaluate_charging_start(grid_to_home: float, max_charging_power: float, actual_charging_power: float, pv_power: float, home_consumption: float, charging_style: int):
    """Evaluate whether to start or stop charging the electric vehicle based on the available power.

    Args:
        - grid_to_home (float): power flow from the grid to home, in watts
        - max_charging_power (float): maximum charging power that can be used for the electric vehicle, in watts
        - actual_charging_power (float): actual charging power being used for the electric vehicle, in watts
        - pv_power (float): power generated by the solar panels, in watts
        - home_consumption (float): power consumed by the household, in watts
        - charging_style (int): the style to charge the ev: aggressive(0) or conservative(1)

    Returns:
        A tuple containing:
        - status (str): a string containing the status of the charging process and the available power, in watts
        - sleep_time (int): duration of time the function should sleep for, in seconds
        - sleep_str (str): a string representation of the sleep time, in the format of mm
    """
    if charging_style == 0:
        if max_charging_power >=800 and grid_to_home <=1600:
            return adaptive_charging()
        else:
            if 500 <= max_charging_power < 800 and grid_to_home < 1600:
                return slow_charging(7)
            else:
                return no_charging()

    elif charging_style == 1:
        if max_charging_power >= 800 and grid_to_home <= 800:
            return adaptive_charging()
        else:
            if 500 <= max_charging_power < 800 and grid_to_home < 800:
                retrun slow_charging(6)

            else:
                return no_charging()

    else:
        raise ValueError("The provided charging style is invalid, there are only two style: 0 -> aggressive and 1 -> conservative; defaultÂ´is conservative")            


def loop(buffer: float, style: int)-> None:
    """
    This function retrieves solar and home energy data from an API and then calculates available and maximum charging
    power for an electric vehicle. It then uses this information to either allow or prevent charging of the vehicle and
    sets the appropriate charging current. It also prints the current status of the system and waits for a specified
    amount of time before running the loop again.

    Args:
    - data_url (str): URL of the API that provides solar and home energy data
    - buffer (float): Buffer power in watts that needs to be left available to prevent power cuts or tripping
    - steps (dict): Mapping of different charging currents to their corresponding power requirements

    Returns: None
    """

    while True:
        # Check for 1 phase usage
        check_1_phase()
        pv_power, home_consumption, actual_charging_power, grid_to_home = retrieve_values()
        available_power = calculate_available_power(pv_power, home_consumption, buffer, actual_charging_power)
        max_charging_power = check_max_charging_power(available_power)

        # Create status message
        status = f"Status:\n Grid Power to Home: {grid_to_home}W\n Pv Power: {pv_power}W\n Home consumption: {home_consumption}W\n PV Power Available for Grid: {round(pv_power - home_consumption + actual_charging_power, 3)}W\n Available charging power: {available_power}W\n Maximum charging power that can be drawn from the PV:  {max_charging_power}W\n"

        # Check weather to charge or not based on available grid and pv power
        status_text, sleep_time, sleep_string = evaluate_charging_start(grid_to_home, max_charging_power, actual_charging_power, pv_power, home_consumption, style)

        # Print the status message and wait for specified amount of time
        status_and_sleep(status, sleep_string, sleep_time, status_text)

def main(buffer_power=200, style=1) -> None:
    """
    The main function that runs the loop for the EV charger.

    Args:
        buffer_power: the power that shoulkd remain untouched and not be used for ev charging, that shoukld be available for other home consumers
        style: the style in what the ev shoulld get charged, more aggressive, should result in fewer stops, but potentialy more power drawn from grid, more conservative, should result in more stops, but nearly no power draw from grid

    Returns:
        None
    """

    # Initialize the counter and last called time
    counter.count = 0
    counter.last_called = None

    if check_1_phase(True):
        loop(buffer_power, style)

# check if script is run as a script
if __name__ == "__main__":
    import argparse
    parser = argparse.ArgumentParser()
    parser.add_argument('--buffer', type=int, default=200, help='the power that should be left of the PV power for the home and should not be drawn for ev charging, default is 200W')
    parser.add_argument('--style', type=str, help='should the algorithm be more aggressive (0) or more conservative (1) in charging the ev aggressive should result in fewer stops, but potencial draw from gird, conservative should stop more often and will try to not draw any power from grid')
    args = parser.parse_args()

    main(args.buffer, args.style)