from logger import log_info
from status import status_and_sleep
from count_stops import stops_counter
from check_1_phase import check_1_phase
from count_phase_changes import phase_counter
from modbus_data import return_data_to_script
from get_data import retrieve_values, get_phase
from charging_profiles import adaptive_charging, slow_charging, no_charging
from power_calculations import calculate_available_power, check_max_charging_power

# global indicator for three phase charging
global use_three_phases

# Initialize the counter and last called time
stops_counter.count = 0
stops_counter.last_called = None

phase_counter.count = 0
phase_counter.last_called = None

def evaluate_charging_start(grid_to_home: float, max_charging_power: float, actual_charging_power: float, charging_style: int, home_consumption: float, pv_power: float, available_power: float):
    """Evaluate whether to start or stop charging the electric vehicle based on the available power.

    Args:
        - grid_to_home (float): power flow from the grid to home, in watts
        - max_charging_power (float): maximum charging power that can be used for the electric vehicle, in watts
        - actual_charging_power (float): actual charging power being used for the electric vehicle, in watts
        - charging_style (int): the style to charge the ev: aggressive(0) or conservative(1)
        - home_consumption (float): the amount of power used by the home
        - pv_power (float): power generated by pv

    Returns:
        A tuple containing:
        - status (str): a string containing the status of the charging process and the available power, in watts
        - sleep_time (int): duration of time the function should sleep for, in seconds
        - sleep_str (str): a string representation of the sleep time, in the format of mm
    """

    if charging_style == 0:
        grid_to_home_ref = 2000
        amps_slow = 7
    elif charging_style == 1:
        grid_to_home_ref = 800
        amps_slow = 6
    else:
        raise ValueError("The provided charging style is invalid, there are only two style: 0 -> aggressive and 1 -> conservative; defaultÂ´is conservative")

    if ( max_charging_power > 4500 and actual_charging_power > 3600 ) or ( max_charging_power > 4500 and actual_charging_power < 10 ):
        charging_steps = {6 : 4200, 7 : 4800, 8 : 5400}
        use_three_phases = True
        return adaptive_charging(max_charging_power, actual_charging_power, charging_steps, use_three_phases)

    if max_charging_power >= 1000 and grid_to_home <= grid_to_home_ref:
        charging_steps = {6 : 1300, 7 : 1600, 8 : 1800, 9 : 2000, 10 : 2300, 11 : 2500, 12 : 2700, 13 : 3000, 14 : 3200, 15 : 3400, 16 : 3700}
        use_three_phases = False
        return adaptive_charging(max_charging_power, actual_charging_power, charging_steps, use_three_phases)

    else:
        if 750 <= max_charging_power < 1000 and grid_to_home < grid_to_home_ref:
            return slow_charging(amps_slow, grid_to_home, max_charging_power, actual_charging_power)
        else:
            return no_charging(available_power, get_phase())

def loop(buffer: float, style: int, force: bool = False)-> None:
    """
    This function retrieves solar and home energy data from an API and then calculates available and maximum charging
    power for an electric vehicle. It then uses this information to either allow or prevent charging of the vehicle and
    sets the appropriate charging current. It also prints the current status of the system and waits for a specified
    amount of time before running the loop again.

    Args:
    - buffer (float): Buffer power in watts that needs to be left available to prevent power cuts or tripping
    - style (str): the charging style to be used
    - force (bool): to ignore or not ignore one phase check on start

    Returns: None
    """

    use_three_phases = force

    while True:
        ##############################################################################################################################################################################################
        ## ToDo:                                                                                                                                                                                    ##
        ##      - add tibber check and chnage charging style according to the price, either price level: VERY_CHEAP, CHEAP, NORMAL, EXPENSIVE, VERY_EXPENSIVE or based on the actual price when below a threshold       ##
        ##      - check tibber price only every hour since they change only every hour                                                                                                              ##
        ##############################################################################################################################################################################################

        # Check for 1 phase usage
        check_1_phase(False, use_three_phases)

        #pv_power, home_consumption, actual_charging_power, grid_to_home = retrieve_values()
        pv_power, home_consumption, actual_charging_power, grid_to_home = return_data_to_script()
        available_power = calculate_available_power(pv_power, home_consumption, buffer, actual_charging_power)
        max_charging_power = check_max_charging_power(available_power)

        # Create status message
        status = f"Grid to Home: {grid_to_home}W; Pv Power: {pv_power}W; Home consumption: {home_consumption}W; PV Power for Grid: {round(pv_power - home_consumption + actual_charging_power, 3)}W; Available charging power: {available_power}W"

        # Check wether to charge or not based on available grid and pv power
        status_text, sleep_time, use_three_phases, phase_log, charging_log = evaluate_charging_start(grid_to_home, max_charging_power, actual_charging_power, style, home_consumption, pv_power, available_power)

        #Count phase changes and charging stops
        if phase_log != None:
          phase_counter()
        if charging_log == "Stopping Charging\n":
          stops_counter()

        # Print the status message and wait for specified amount of time
        status_and_sleep(status, sleep_time, status_text, phase_log, charging_log)

def main(buffer_power=200, style=1, force=False) -> None:
    """
    The main function that runs the loop for the EV charger.

    Args:
        buffer_power: the power that shoulkd remain untouched and not be used for ev charging, that shoukld be available for other home consumers
        style: the style in what the ev shoulld get charged, more aggressive, should result in fewer stops, but potentialy more power drawn from grid, more conservative, should result in more stops, but nearly no power draw from grid

    Returns:
        None
    """
    start = f"\nStarting Pv Surplus EV charging, buffer power: {buffer_power}W, charging style: {'aggressive' if style == 0 else 'conservative'}, force start: {force}\n"
    print (start)
    if check_1_phase(True, force):
        log_info(start)
        loop(buffer_power, style, force)

# check if script is run as a script
if __name__ == "__main__":
    import argparse
    parser = argparse.ArgumentParser()
    parser.add_argument('--buffer', type=int, default=200, help='the power that should be left of the PV power for the home and should not be drawn for ev charging, default is 200W')
    parser.add_argument('--style', type=int, default=1,help='should the algorithm be more aggressive (0) or more conservative (1) in charging the ev aggressive should result in fewer stops, but potencial draw from gird, conservative should stop more often and will try to not draw any power from grid')
    parser.add_argument('--force', type=bool, default=False, help='should the algorithm start wether or not one phase is used')
    args = parser.parse_args()

    main(args.buffer, args.style, args.force)